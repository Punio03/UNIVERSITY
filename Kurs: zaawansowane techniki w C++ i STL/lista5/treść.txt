Zadanie 1 (4 pkt).
Zaprogramuj algorytm stacji rozrządowej Dijkstry, który przekształca wyrażenie arytmetyczne z postaci infiksowej z nawiasami do postaci postfiksowej bez nawiasów (Odwrotna Notacja Polska). Wykorzystaj do tego celu kolekcje standardowe.
W pierwszym kroku należy przekształcić wyrażenie infiksowe zapisane w łańcuchu znakowym string na ciąg symboli i umieścić je w kolekcji forward_list<symbol>.
Sama klasa symbol ma być tuplą kilku elementów: pierwszy to wartość wyliczeniowa opisująca rodzaj symbolu (wyliczenie zdefiniuj za pomocą enum class), drugi to opcjonalna wartość liczbowa typu double związana z symbolem (dla zwykłych literałów liczbowych albo dla zdefiniowanych stałych jak π czy e) a trzeci to opcjonalna nazwa typu string (dla stałych, zmiennych oraz dla funkcji i działań arytmetycznych), potrzebny będzie także element typu int do przechowywania priorytetów działań i funkcji. Zmienne przechowuj w nieuporządkowanej kolekcji par unordered_set<pair<string, double>>.
Funkcja przekształcająca zapis infiksowy wyrażenia na postać postfiksową dostaje jako argument forward_list<symbol> (wyrażenie w zapisie infiksowym) i zwraca jako wynik także forward_list<symbol> (wyrażenie w zapisie postfiksowym). Zaprogramuj algorytm stacji rozrządowej Dijkstry do tego przekształcenia, wykorzystując stos symboli stack<symbol>.
Zadanie 2 (6 pkt).
Zdefiniuj strukturę danych do przetrzymywania ważonego grafu dynamicznego w postaci list sąsiadów. Wspomniana dynamika grafu oznacza, że można dodawać nowe a także usuwać istniejące wierzchołki z grafu. Wierzchołki w grafie niech posiadają swoje unikalne identyfikatory typu string (identyfikator nie może być pusty). Co się tyczy krawędzi, krawędzie można dodawać i usuwać, a także zmieniać ich wagę. Każda krawędź w grafie ma przypisaną wagę typu double (wagi mogą być ujemne). Wykorzystaj do tego celu kontenery z STL.
Dodatkowo zdefiniuj funkcję, która wyznaczy MST (minimalne drzewo rozpinające) w zadanym grafie. Wynikiem działania tej funkcji także ma być graf (będący drzewem). Zaprogramuj algorytm Prima do tego celu, wykorzystując kolejkę priorytetową wierzchołków osiągalnych ze zbudowanego do danego momentu MST.
